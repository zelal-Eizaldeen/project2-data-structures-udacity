{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red25\green60\blue255;\red255\green255\blue255;\red0\green0\blue0;
\red252\green252\blue249;\red255\green255\blue255;\red253\green253\blue248;\red255\green255\blue255;\red253\green253\blue248;
\red255\green255\blue255;\red254\green254\blue248;}
{\*\expandedcolortbl;;\cssrgb\c12594\c35385\c100000;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c1\c1;
\cssrgb\c98928\c98928\c98020;\cssrgb\c100000\c100000\c99956\c0;\cssrgb\c99342\c99337\c97934;\cssrgb\c100000\c100000\c99971\c0;\cssrgb\c99239\c99236\c97956;
\cssrgb\c100000\c100000\c99926\c0;\cssrgb\c99545\c99538\c97886;}
\margl1440\margr1440\vieww16920\viewh8640\viewkind0
\deftab720
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\

\f1\b\fs32 \cf3 \ul \ulc3 1- LRU-Cache problem\

\f0\b0\fs24 \cf2 \ulnone \
def put(self, key, value):\
        # If the cache is full, remove the last element                  \
        bucket_index = self.get_bucket_index(key)   \
        new_node = LinkedListNode(key, value)                       \
        head = self.bucket_array[bucket_index]  \
        if key > len(self.bucket_array):\
            self.delete(key) \
            \
        while head is not None:\
            if head.key == key:\
                head.value = value\
                return\
            head = head.next \
        head = self.bucket_array[bucket_index]\
        new_node.next = head                                         \
        self.bucket_array[bucket_index] = new_node                 \
        self.num_entries += 1\

\f1\b\fs28 \cf4 f(n) =  O(n) n is number of element in the bucket_array\
\cf2 \
\
def get(self, key):\
        # In case of a cache hit\
        bucket_index = self.get_bucket_index(key) \
        head = self.bucket_array[bucket_index]\
        \
        while head is not None:\
            if head.key == key:\
                return head.value\
            head = head.next           \
        return -1\
\cf4 f(n) = O(1)    we get the element by the key\
\cf2 \
\pard\pardeftab720\sl360\partightenfactor0

\f0\b0\fs24 \cf2 \outl0\strokewidth0 \strokec5 \
\cf2 \cb6 \strokec7 def get_hash_code(self, key):\
        key = str(key)\
        num_buckets = len(self.bucket_array)                          \
        current_coefficient = 1                                       \
        hash_code = 0\
        \
        for character in key:\
            hash_code += ord(character) * current_coefficient\
            hash_code = hash_code % num_buckets                       # compress hash_code (Mod operation)\
            current_coefficient *= self.p\
            current_coefficient = current_coefficient % num_buckets   # compress coefficient as well\
\
        return hash_code % num_buckets\
\cf2 \cb8 \strokec9 \

\f1\b \cf4 \cb6 \strokec7 f(n) O(4n)  # n is the number of character\
\cf2 \cb8 \strokec9 \
\
\pard\pardeftab720\sl360\partightenfactor0

\fs28 \cf2 \cb6 \strokec7 def get_bucket_index(self, key):\
        bucket_index = self.get_hash_code(key)                        \
        return bucket_index\
\cf4 \cb10 \strokec11 f(n) = O(1)   \cf4 \cb10 \outl0\strokewidth0 \
f(n) = O(n) + O(1) = O(n)}